{
  package ast

  import "strings"

  func ifaceStr(val interface{}) string {
    str := ""
    for _, seg := range val.([]interface{}) {
      str = str + string(seg.([]byte))
    }

    return str
  }

  func ifaceSequences(val interface{}) []Sequence {
    sentences := []Sequence{}
    for _, node := range val.([]interface{}) {
      sentences = append(sentences, node.(Sequence))
    }

    return sentences
  }

  func ifaceNodes(val interface{}) []Node {
    nodes := []Node{}
    for _, node := range val.([]interface{}) {
      nodes = append(nodes, node.(Node))
    }

    return nodes
  }

  func methodName(name string) string {
    camel := ""
    for _, word := range strings.Split(name, "-") {
      camel += strings.Title(word)
    }

    return camel
  }
}

Booklit <- node:Paragraphs !. {
  return node, nil
}

Paragraphs <- "\n"* paragraphs:(p:Paragraph "\n"* { return p, nil })+ {
  return Sequence(ifaceNodes(paragraphs)), nil
}

Paragraph <- sentences:(s:Sentence "\n" { return s, nil })+ {
  return Paragraph(ifaceSequences(sentences)), nil
}

Sentence <- [ \t]* words:(Word)+ {
  return Sequence(ifaceNodes(words)), nil
}

Word <- val:(String / Invoke) {
  return val, nil
}

String <- str:[^\\{}\n]+ { return String(c.text), nil } / '\\' [\\{}] { return String(c.text[1:]), nil }

Invoke <- '\\' name:([a-z-]+) args:(Argument*) {
  return Invoke{
    Method: methodName(ifaceStr(name)),
    Arguments: ifaceNodes(args),
  }, nil
}

Argument <- '{' node:(Sentence / Paragraphs) [ \t]* '}' {
  return node, nil
}
